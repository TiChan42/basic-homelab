#!/bin/bash
# ============================================
# Home Assistant Restore Script – managed by Ansible
# Restores HA from a validated NAS backup by
# uploading it to HA and triggering a partial restore
# via the Supervisor API.
#
# Usage:
#   ha_restore.sh          – restore with overwrite protection
#   ha_restore.sh --force  – skip overwrite protection
# ============================================
set -euo pipefail

REFRESH_TOKEN_FILE="{{ ha_refresh_token_file }}"
BACKUP_DIR="{{ nas_backup_mount }}/homeassistant/homeassistant"
KEEP_COUNT={{ ha_backup_keep_count }}
MIN_BACKUP_SIZE={{ ha_backup_min_size }}
API_HELPER="{{ ha_supervisor_api_path | default('/home/homelab/basic-homelab/ansible-playbooks/services/102-homeassistant/files/ha_supervisor_api.py') }}"
LOG_TAG="ha-restore"
HA_URL="http://{{ hostvars[groups['homeassistant'][0]]['ansible_host'] }}:{{ ha_port | default('8123') }}"
ADMIN_USER="{{ admin_user }}"
ADMIN_PASS="{{ admin_password }}"

BACKUP_PREFIX="$BACKUP_DIR/ha_backup"
FORCE=false
if [ "${1:-}" = "--force" ]; then
  FORCE=true
fi

# -----------------------------------------------
# Helper: obtain a fresh access token via refresh
# -----------------------------------------------
get_access_token() {
  local TOKEN_RESPONSE
  TOKEN_RESPONSE=$(curl -s -X POST "$HA_URL/auth/token" \
    -d "grant_type=refresh_token" \
    -d "client_id=$HA_URL/" \
    -d "refresh_token=$REFRESH_TOKEN")

  echo "$TOKEN_RESPONSE" | jq -r '.access_token // empty'
}

# -----------------------------------------------
# Helper: full login flow (username/password)
# Returns new access token and saves refresh token
# -----------------------------------------------
login_and_save_token() {
  local FLOW FLOW_ID RESULT AUTH_CODE TOKEN_RESP NEW_ACCESS NEW_REFRESH

  # Step 1: Initiate login flow
  FLOW=$(curl -s -X POST "$HA_URL/auth/login_flow" \
    -H "Content-Type: application/json" \
    -d "{\"client_id\":\"$HA_URL/\",\"handler\":[\"homeassistant\",null],\"redirect_uri\":\"$HA_URL/\"}")
  FLOW_ID=$(echo "$FLOW" | jq -r '.flow_id // empty')

  if [ -z "$FLOW_ID" ]; then
    logger -t "$LOG_TAG" "ERROR: Failed to initiate login flow."
    return 1
  fi

  # Step 2: Submit credentials
  RESULT=$(curl -s -X POST "$HA_URL/auth/login_flow/$FLOW_ID" \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"$ADMIN_USER\",\"password\":\"$ADMIN_PASS\",\"client_id\":\"$HA_URL/\"}")
  AUTH_CODE=$(echo "$RESULT" | jq -r '.result // empty')

  if [ -z "$AUTH_CODE" ]; then
    logger -t "$LOG_TAG" "ERROR: Login failed. Response: $RESULT"
    return 1
  fi

  # Step 3: Exchange auth code for tokens
  TOKEN_RESP=$(curl -s -X POST "$HA_URL/auth/token" \
    -d "grant_type=authorization_code" \
    -d "client_id=$HA_URL/" \
    -d "code=$AUTH_CODE")
  NEW_ACCESS=$(echo "$TOKEN_RESP" | jq -r '.access_token // empty')
  NEW_REFRESH=$(echo "$TOKEN_RESP" | jq -r '.refresh_token // empty')

  if [ -z "$NEW_ACCESS" ] || [ -z "$NEW_REFRESH" ]; then
    logger -t "$LOG_TAG" "ERROR: Token exchange failed."
    return 1
  fi

  # Save new refresh token for future use (backup script, etc.)
  echo "$NEW_REFRESH" > "$REFRESH_TOKEN_FILE"
  REFRESH_TOKEN="$NEW_REFRESH"
  logger -t "$LOG_TAG" "New refresh token saved to $REFRESH_TOKEN_FILE"

  echo "$NEW_ACCESS"
}

# -----------------------------------------------
# Helper: validate a backup archive
# -----------------------------------------------
validate_backup() {
  local ARCHIVE="$1"

  if [ ! -f "$ARCHIVE" ]; then
    return 1
  fi

  if [ ! -s "$ARCHIVE" ]; then
    logger -t "$LOG_TAG" "Validation failed: $(basename "$ARCHIVE") is empty."
    return 1
  fi

  local FILE_SIZE
  FILE_SIZE=$(stat -c%s "$ARCHIVE" 2>/dev/null || stat -f%z "$ARCHIVE" 2>/dev/null || echo "0")
  if [ "$FILE_SIZE" -lt "$MIN_BACKUP_SIZE" ]; then
    logger -t "$LOG_TAG" "Validation failed: $(basename "$ARCHIVE") too small (${FILE_SIZE} bytes)."
    return 1
  fi

  if ! tar -tf "$ARCHIVE" > /dev/null 2>&1; then
    logger -t "$LOG_TAG" "Validation failed: $(basename "$ARCHIVE") is not a valid tar archive."
    return 1
  fi

  return 0
}

# -----------------------------------------------
# Prerequisites
# -----------------------------------------------
if [ ! -f "$REFRESH_TOKEN_FILE" ]; then
  logger -t "$LOG_TAG" "ERROR: Refresh token file not found at $REFRESH_TOKEN_FILE. Cannot restore."
  exit 1
fi
REFRESH_TOKEN=$(cat "$REFRESH_TOKEN_FILE")

if [ ! -f "$API_HELPER" ]; then
  logger -t "$LOG_TAG" "ERROR: API helper not found at $API_HELPER"
  exit 1
fi

# Check NFS mount is available
if ! mountpoint -q "{{ nas_mount }}"; then
  logger -t "$LOG_TAG" "ERROR: NAS mount not available at {{ nas_mount }}"
  exit 1
fi

# Check if HA is reachable first
HA_TOKEN=$(get_access_token)
if [ -z "$HA_TOKEN" ]; then
  logger -t "$LOG_TAG" "ERROR: Failed to obtain access token. HA may not be ready."
  exit 1
fi

# -----------------------------------------------
# Overwrite protection (skip with --force)
# Uses entity count as indicator: fresh HA after
# onboarding has ~30-40 entities; a configured or
# restored HA has significantly more (80+).
# -----------------------------------------------
if [ "$FORCE" = false ]; then
  ENTITY_COUNT=$(curl -s -H "Authorization: Bearer $HA_TOKEN" "$HA_URL/api/states" 2>/dev/null | jq 'length' 2>/dev/null || echo "0")

  if [ "${ENTITY_COUNT:-0}" -gt 50 ]; then
    logger -t "$LOG_TAG" "HA already has data ($ENTITY_COUNT entities). Use --force to override. No restore needed."
    exit 0
  fi

  logger -t "$LOG_TAG" "HA has only $ENTITY_COUNT entities – checking for NAS backup to restore..."
fi

if [ "$FORCE" = true ]; then
  logger -t "$LOG_TAG" "Force mode enabled – skipping overwrite protection."
fi

# -----------------------------------------------
# Find best available backup (0 → 1 → 2 → ...)
# -----------------------------------------------
RESTORE_FILE=""

for (( i = 0; i < KEEP_COUNT; i++ )); do
  CANDIDATE="${BACKUP_PREFIX}.${i}.tar"
  if validate_backup "$CANDIDATE"; then
    RESTORE_FILE="$CANDIDATE"
    if [ "$i" -gt 0 ]; then
      logger -t "$LOG_TAG" "WARNING: Backups 0-$((i-1)) invalid, falling back to backup ${i}."
    else
      logger -t "$LOG_TAG" "Using newest backup (0)."
    fi
    break
  fi
done

if [ -z "$RESTORE_FILE" ]; then
  logger -t "$LOG_TAG" "No valid NAS backup found (checked 0-$((KEEP_COUNT-1))). Starting fresh."
  exit 0
fi

FILE_SIZE=$(stat -c%s "$RESTORE_FILE" 2>/dev/null || echo "0")
logger -t "$LOG_TAG" "Restoring from $(basename "$RESTORE_FILE") (${FILE_SIZE} bytes)..."

# -----------------------------------------------
# Step 1: Upload backup to HA
# -----------------------------------------------
logger -t "$LOG_TAG" "Uploading backup to HA..."

UPLOAD_RESP=$(curl -s -w "\n%{http_code}" -X POST \
  "$HA_URL/api/hassio/backups/new/upload" \
  -H "Authorization: Bearer $HA_TOKEN" \
  -F "file=@$RESTORE_FILE")

UPLOAD_HTTP=$(echo "$UPLOAD_RESP" | tail -1)
UPLOAD_BODY=$(echo "$UPLOAD_RESP" | head -1)
BACKUP_SLUG=$(echo "$UPLOAD_BODY" | jq -r '.data.slug // empty' 2>/dev/null)

if [ "$UPLOAD_HTTP" != "200" ] || [ -z "$BACKUP_SLUG" ]; then
  logger -t "$LOG_TAG" "ERROR: Backup upload failed (HTTP $UPLOAD_HTTP). Response: $UPLOAD_BODY"
  exit 1
fi

logger -t "$LOG_TAG" "Backup uploaded (slug: $BACKUP_SLUG)."

# -----------------------------------------------
# Step 2: Read backup metadata to determine type
# and build the correct restore payload.
# -----------------------------------------------
BACKUP_META=$(tar -xf "$RESTORE_FILE" -O ./backup.json 2>/dev/null)
BACKUP_TYPE=$(echo "$BACKUP_META" | jq -r '.type // "full"' 2>/dev/null)

if [ "$BACKUP_TYPE" = "partial" ]; then
  # Build partial restore payload from backup metadata
  ADDON_SLUGS=$(echo "$BACKUP_META" | jq -c '[.addons[].slug]' 2>/dev/null || echo "[]")
  FOLDERS=$(echo "$BACKUP_META" | jq -c '.folders // []' 2>/dev/null || echo "[]")
  HAS_HA=$(echo "$BACKUP_META" | jq -r '.homeassistant // empty' 2>/dev/null)

  RESTORE_DATA="{\"backup_id\":\"$BACKUP_SLUG\",\"agent_id\":\"hassio.local\""
  if [ -n "$HAS_HA" ]; then
    RESTORE_DATA="$RESTORE_DATA,\"homeassistant\":true"
  fi
  RESTORE_DATA="$RESTORE_DATA,\"addons\":$ADDON_SLUGS,\"folders\":$FOLDERS}"

  logger -t "$LOG_TAG" "Partial backup detected. Restoring: addons=$ADDON_SLUGS folders=$FOLDERS homeassistant=$([ -n "$HAS_HA" ] && echo true || echo false)"
  RESTORE_CMD="backup/restore/partial"
else
  RESTORE_DATA="{\"backup_id\":\"$BACKUP_SLUG\",\"agent_id\":\"hassio.local\"}"
  logger -t "$LOG_TAG" "Full backup detected. Triggering full restore..."
  RESTORE_CMD="backup/restore/full"
fi

# -----------------------------------------------
# Step 3: Trigger restore via WebSocket API
# The WebSocket connection will drop when HA
# restarts – this is expected and not an error.
# -----------------------------------------------
RESTORE_RESP=$(python3 "$API_HELPER" "$HA_URL" "$HA_TOKEN" ws "$RESTORE_CMD" \
  "$RESTORE_DATA" 2>&1) || true

logger -t "$LOG_TAG" "Restore triggered ($RESTORE_CMD). Response: $RESTORE_RESP"

# -----------------------------------------------
# Step 4: Wait for HA to come back after restore,
# then re-authenticate and save new refresh token.
# The old refresh token is invalidated by the
# restore (auth database is replaced).
# -----------------------------------------------
logger -t "$LOG_TAG" "Waiting for HA to restart after restore..."
sleep 30

for i in $(seq 1 24); do
  HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HA_URL/api/" 2>/dev/null || echo "000")
  if [ "$HTTP_CODE" = "401" ] || [ "$HTTP_CODE" = "200" ]; then
    logger -t "$LOG_TAG" "HA is back (HTTP $HTTP_CODE after ${i}x10s)."
    break
  fi
  sleep 10
done

# Re-authenticate to get a valid refresh token
NEW_TOKEN=$(login_and_save_token)
if [ -n "$NEW_TOKEN" ]; then
  logger -t "$LOG_TAG" "Re-authentication successful after restore."
else
  logger -t "$LOG_TAG" "WARNING: Could not re-authenticate after restore. Run login manually to update refresh token."
fi

logger -t "$LOG_TAG" "Restore complete. HA should be fully operational."
